[TOC]

### 预解析
- 在代码整体执行之前，先解析一部分。
- 预解析之后，代码才会从上往下依次整体执行，但是预解析执行过的代码不会重复执行。
- js中预解析会把声明部分的代码预先执行。

#### 声明相关的代码可以分为两部分：
1. 变量声明 ==> 通过var关键字定义的变量。
2. 函数声明 ==> 通过function关键字声明的函数。

#### 变量声明提升的特点:
- 在声明变量的前面，可以使用这个变量

```
    console.log(a);
    var a = 10;
    console.log(a);

    /*
    * 预解析时执行的代码：
    * var a;
    *
    * 预解析之后执行的代码:
    *  console.log(a); //undefined
    *  a = 10;
    *  console.log(a); //10
    * */
```

### 定义函数的方式：
#### 1、函数声明式定义的特征
- 以function关键字开头定义，并且定义在全局 或 直接嵌套在另一个函数内，这种形式定义的函数就是函数声明式。
- 函数声明式定义的函数其他特征：
1. 会被预解析
2. 函数必须有名字

```
    // 这是函数声明式
    function fn() {  }

    // 外面的是函数表达式
    (function () {
        // 里面的是函数声明式
        function f() { }
    })();

```



#### 2、函数表达式定义的特征
- 不是以function关键字开头定义的函数,或者函数嵌套在非函数的代码块中, 都是函数表达式。
- 函数表达式的其他特征：
1. 不会被预解析
2. 函数名字可有可无
3. 函数的名字只能在函数内部使用

```
    // 这是函数表达式
    var f = function () { };

    {
        // 在非函数的代码块中定义的函数是函数表达式
        function f() {}
    }

    // 这是函数表达式
    (function () { })();
```

```
    var fn = function f() {
        console.log(f); // 函数表达式的名字，只能在里面使用
    };
    fn();
    console.log(f);  // 函数表达式的名字，在外面无法使用
```
#### 函数声明提升
- 函数声明提升的特点是，在函数声明的前面，可以调用这个函数。

```
    // 函数声明可以提前调用
    fn(); // 1
    function fn() {
        console.log(1);
    }

    (function () {
        // 函数声明可以提前调用
        f();
        function f() {
            console.log(111);
        }
    })();
```


### 预解析时遇到的重名问题：
#### 关于预解析时重名处理的特点：
- 凡是遇到重名的变量声明，那么忽略；
- 凡是遇到重名的函数声明，当前的函数覆盖之前的。

#### 1、预解析时如果遇到重复的变量声明，那么忽略。
```
    console.log(a);
    var a = 1;
    var a = 100;
    console.log(a);

    /*
    * 预解析：
    * var a;
    * var a;  // 忽略
    *
    * 预解析之后：
    *  console.log(a); //undefined
    *  a = 1;
    *  a = 100;
    *  console.log(a); //100
    * */
```

#### 2、预解析时如果遇到重复的函数声明，保留后面的函数。
```
    fn();
    function fn() {
        console.log(111);
    }
    function fn() {
        console.log(222);
    }
    fn();

    /*
    * 预解析：
    * 第一个fn函数声明
    * 第二个fn函数声明，发现重名，保留后面的函数
    *
    * 预解析之后：
    * fn(); //222
    * fn(); //222
    * */
```

#### 3、预解析时如果遇到变量与函数重名的情况，保留函数。
```
    console.log(fn);
    var fn = 10;
    function fn() {
        console.log(111);
    }
    var fn = 20;
    function fn() {
        console.log(222);
    }
    console.log(fn);

    /*
    * 预解析：
    * var fn，
    * 第一个fn函数声明,发现重名，保留现在打印111的函数，
    * var fn; 发现重名，忽略，
    * 第二个fn函数声明，发现重名，保留现在打印222的函数，
    *
    * 预解析之后：
    * console.log(fn);  // 打印222的函数
    * fn = 10;
    * fn = 20;
    * console.log(fn);   // 打印20
    * */
```

#### 一个函数声明式的语法，写在非函数的代码块中，理论上这是函数表达式。但是对于这种函数，浏览器会预解析它的名字。
```
    console.log(fn);
    {
        // 这是函数表达式
        function fn() {

        }
    }
    console.log(fn);
    
    /*
    * 预解析：
    * var fn;
    *
    * 预解析之后：
    * console.log(fn);  //undefined
    * fn = function fn() {}
    * console.log(fn);  //function fn() {}
    * */
```

#### 函数执行时内部也存在预解析
```
    function fn(par) {

        // 形参一定是在代码整体执行之前复的值。
        console.log(par);
        console.log(a);
        console.log(f);

        var a = 1;
        var par = 111;
        function f() {
            console.log(111);
        }
    }
    fn(10);

        /*
        * 函数调用时，会先给形参赋值
        * var par = 10；
        *
        * 预解析：
        * var a；
        * var par；  // 发现重名，忽略
        * f函数预解析；
        *
        * 预解析之后：
        * console.log(par);  // 10
        * console.log(a);  // undefined
        * console.log(f); // f函数体
        * */
```

***

### 作用域：
- 变量的有效范围
- 如何检测一个变量的作用域：在指定的区域内使用这个变量，如果不报错，说明这个变量的作用域包含此区域。

#### 全局变量和局部变量：
1. 全局变量：在任何地方都可以使用的变量称之为全局变量
> 如何定义全局变量：在函数外定义的变量都是全局变量。

2. 局部变量：只有指定地方可以使用的变量称之为局部变量
> 如何定义局部变量：在函数内声明的变量都是局部变量。

3. 全局变量和局部变量就是通过作用域的大小来对变量进行的种类划分。

#### 函数作用域：
- 只有函数能够划分变量的作用域，这种作用域的规则就叫函数作用域。

```
    (function () {
        var b = 1;
    })();
    console.log(b);
```

#### 块级作用域：
- 凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域。

```
    {
        const obj = {};
        console.log(obj);
    }
    console.log(obj);// 不能获取obj,报错
```


#### 词法作用域（静态作用域）：
- 如果在函数内访问一个变量，优先找局部变量和形参，
- 如果没有找到，就去 **定义该函数** 的环境中查找
- 直到全局为止。

#### 块级作用域、函数作用域、词法作用域之间的区别：
1. 块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域
2. 词法作用域描述的是，变量的查找规则。

#### 块级作用域、函数作用域、词法作用域之间的关系：
1. 块级作用域 包含 函数作用域
2. 词法作用域 与 块级作用域&函数作用域之间没有任何交集，他们从两个角度描述了作用域的规则。

#### 动态作用域：
- 如果在函数内访问一个变量，优先找局部变量和形参，
- 如果没有找到，就去 **调用该函数** 的环境中查找
- 直到全局为止。

```
    var a = 100;
    var b = 9999999;
    (function () {
        var a = 200;
        var b = 888888;
        function fn() {
            var a = 1;
            console.log(a);  // 1
            console.log(b);  // 888888
        }

        (function () {
            var a = 100;
            var b = 666666;
            fn();
        })();
    })();
```


